{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Language style guidelines","text":""},{"location":"csharp/var/","title":"Implicitly-typed local variables","text":"<p>The <code>var</code> keyword allows the compiler to infer the variable's type. One should keep in mind:</p> <ul> <li>Is the type clear given the context?</li> <li>Should emphasis be given to a types nullability?</li> </ul>"},{"location":"csharp/var/#examples-of-when-to-use-var","title":"Examples of when to use <code>var</code>","text":"<p>A good reason is to improve readability. Without <code>var</code>, declarations are more verbose. Multiple verbose delcarations can hurt readability.</p> <p>Take the following examples:</p> <p>In this example, it is clear that <code>HttpResponseMessage</code> is not nullable  (for those with experience of the library). <pre><code>var response = await client.SendAsync(uri);\n</code></pre> Following on, the deserialized response type would actually be inferred as <code>T?</code>. Indeed we can see the type passed to the generic method <code>ReadFromJsonAsync&lt;T&gt;()</code>. <code>var</code> is fine here because of a clear null check following deserialization.</p> <pre><code>var response = await client.GetAsync(uri);\n\nvar content = await response.Content.ReadFromJsonAsync&lt;T&gt;(serializerOptions);\nif (content == null)\n{\n    // do something...\n} \n</code></pre>"},{"location":"csharp/var/#when-to-avoid-var","title":"When to avoid <code>var</code>","text":""},{"location":"csharp/var/#example-2","title":"Example 2","text":"<p>Suppose we declare a variable; <code>organization</code>, and assign it to another variable. <pre><code>var organization = response.Content;\n</code></pre> Depending on the context, <code>organization</code> could represent a <code>class</code> with properties like Address, CEO, and PhoneNumber; or <code>organization</code> could be a <code>string</code>, representing the organisation's name.</p> <p>Well-written, the context ought to be obvious. But failing this what other options exist?</p> <ul> <li>We could rename the variable to <code>organizationName</code>.</li> <li>We could explicitly declare the type to be a <code>string</code>.</li> </ul>"},{"location":"csharp/var/#example-3","title":"Example 3","text":"<p>Suppose a variable's 'null state' determines some kind of logic.</p> <p>Explicit types for emphasis<pre><code>int? result = reader.ReadAsNullableInt(); \n// Custom extension method because usually a DbReader throws so checking Db.Null first is good.\n</code></pre> If <code>result</code> is <code>null</code>, a particular value might be shown to the user.  A better design might use some kind of discriminated union, nonetheless, this is a common case.</p> <p>or</p> <p><pre><code>string result = reader.ReadAsString();\n</code></pre> Those familiar with DbReader know that it throws on null. Perhaps for that reason, this is not the  best example. it's also not the best example as the extension method alludes to the type.  Regardless of the example, we might wish to empasise that a value can or cannot be null. Explicitly declaring the type allows for this as implictly-typed variables are always nullable.</p>"}]}